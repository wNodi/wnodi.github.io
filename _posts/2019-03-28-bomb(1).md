---
layout:   post
title:    Bomb(1)
subtitle:   Hello world,hello blog!
date:     2019-03-28
author:   吴柚
header-img: post-bg-desk.jpg
catalog:    true
tags:
    - 学习
---

# 实验简介

1. 使用所学知识拆除一个“Binary Bombs” 来增强对程序的机器级表示、汇编语言、调试器和逆向工程等理解；

2. 一个“Binary Bombs” 是一个Linux可执行C程序，包含phase1~phase~6共6个阶段；

3. 炸弹运行各阶段要求输入一个字符串，若输入符合预期，该阶段炸弹被“拆除”，否则“爆炸”；

4. 实验目标是你需要拆除尽可能多的炸弹。

## 实验技能
1. 拆弹技术：为了完成二进制炸弹拆除任务，你需要

* 使用gdb调试器和objdump;

* 单步跟踪调试每一阶段的机器代码

* 理解汇编语言代码的行为或作用

* 进而设法“推断”出拆炸弹所需的目标字符串

* 需要在每一阶段的开始代码前和引爆 炸弹的函数前设置断点，便于调试

2. gdb 指令

* b: （breakpoint）设置断点 例，在phase_1函数前设置断点：b phase_1

* r: （run）执行，直到第一个断点处，若没有断点，就一直执行下去直至结束。
        
* ni:（next/step instructor）单步执行机器指令
        
* x: 显示内存内容,基本用法：以十六进制的形式显示明码地址处开始的20个字节的内容：（gdb）x/20x 明码地址;显示地址明码地址处开始的2个字符串 （gdb） x/2s 明码地址

* info reg： 将当前内存中的全部变量的内容打印出来

### phase_1 解题

1. 解题思路

使用 objdump -d bomb > asm.txt 指令解出汇编代码，再查找到phase_1函数的位置

![](https://i.loli.net/2019/03/28/5c9cdc080d398.png)

> 由phase_1汇编代码得到，将0x804a1e4中的内容mov到0x4(%esp)；再将%esp的内容mov到%eax中，再call字符串比较函数进行比较，当相等的时候正常运行，不相等的时候call explode_bomb函数，故得到phase_1正确输出的字符串的内容为0x804a1e4中的内容。

2. 解题过程

> 打开gdb调试器，使用b和r指令在phase_1设置断点和执行到第一个断点处，即得到了phase_1的解题字符串。

![](https://i.loli.net/2019/03/28/5c9cdc08b5f06.png)

#### phase_2 解题

1. 解题思路

![](https://i.loli.net/2019/03/28/5c9cdc09e6e16.png)

1. 研究phase_2汇编代码可得，此题的解题答案为6个数字，并且由前两个跳转可得到前两个数字分别为 0和1.

2. 由于本题是研究循环，故逐步分析代码执行过程，发现8048be2处是一个循环，但分析后可得，并未找到明显的循环所执行的过程，因此Google了一下此类题的解题过程还是设置断点，然后在通过info reg指令来提取当前寄存器中的值。

![](https://i.loli.net/2019/03/28/5c9cdc0955f58.png)

3. 依次得到6个值后，分别为 0/1/1/2/3/5，尝试拆弹，结果正确。

![](https://i.loli.net/2019/03/28/5c9cdc0a67188.png)

##### 总结

目前来说，此类题目需要掌握汇编语言，并且需要了解gdb调试的基本功能.
