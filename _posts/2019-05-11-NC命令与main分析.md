---
layout:   post
title:    NC命令与main分析
subtitle:   Hello world,hello blog!
date:     2019-05-11
author:   吴柚
header-img: post-bg-desk.jpg
catalog:    true
tags:
    - 二进制
---

##

今天查看第三阶段的文件，发现题目中给出一个实验室搭建的公网来进行测试，使用的是NC命令，所以今天学习了一下NC命令的用法。

### NC命令

#### what's NC?

NetCat，在网络工具中有“瑞士军刀”美誉，其有Windows和Linux的版本。因为它短小精悍（1.84版本也不过25k，旧版本或缩减版甚至更小）、功能实用，被设计为一个简单、可靠的网络工具，可通过TCP或UDP协议传输读写数据。同时，它还是一个网络应用Debug分析器，因为它可以根据需要创建各种不同类型的网络连接。

#### NC可以实现的功能

1. 端口扫描

2. Chat Server

3. 文件传输

4. 目录传输

5. 加密你通过网络发送的数据

6. 流视频

7. 克隆一个设备

8. 打开一个shell

#### NC语法及参数

语法：

```
nc [-hlnruz][-g<网关...>][-G<指向器数目>][-i<延迟秒数>][-o<输出文件>][-p<通信端口>][-s<来源地址>][-v...][-w<超时秒数>][主机名称][通信端口...]
```

参数：

```
-g<网关> 设置路由器跃程通信网关，最多可设置8个。

-G<指向器数目> 设置来源路由指向器，其数值为4的倍数。

-h 在线帮助。

-i<延迟秒数> 设置时间间隔，以便传送信息及扫描通信端口。

-l 使用监听模式，管控传入的资料。

-n 直接使用IP地址，而不通过域名服务器。

-o<输出文件> 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。

-p<通信端口> 设置本地主机使用的通信端口。

-r 乱数指定本地与远端主机的通信端口。

-s<来源地址> 设置本地主机送出数据包的IP地址。

-u 使用UDP传输协议。

-v 显示指令执行过程。

-w<超时秒数> 设置等待连线的时间。

-z 使用0输入/输出模式，只在扫描通信端口时使用。
```

#### PS

虽然学了这么一些NC的用法，但是我还是不太清楚要怎么去测试以及测试什么文件。

### main函数分析

![](https://i.loli.net/2019/05/11/5cd6cd3082cf4.png)

一开始，在经过简单的push入栈操作和mov操作后，比较edi和2的值，随后我从上下文中搜索edi是什么，是否还出现过此寄存器，发现edi的操作都是跟mov操作有关，猜想edi存的东西应该是作为参数传进来的。随后如果edi不等于2的话，跳c47。

```
     bd0:	41 56                	push   %r14
     bd2:	53                   	push   %rbx
     bd3:	50                   	push   %rax
     bd4:	48 89 f3             	mov    %rsi,%rbx   //rsi给rbx
     bd7:	83 ff 02             	cmp    $0x2,%edi	//比较edi和2的值
     bda:	75 6b                	jne    c47 <__cxa_finalize@plt+0x1a7>
```

在c47处，一开始也是进行了一些mov操作给相应的寄存器，随后eax里的内容自身异或，调用了一个fprintf的函数，而这个函数从字面意思我们判定是从一个file流文件中打印里面的内容，随后jmp c3d，在c3d处就是出栈操作，不罗列代码。随后我们接着继续讨论如果edi==2的话，进行什么操作。

```
//edi!=2  从bda处跳转过来	 
c47:	48 8b 05 aa 13 20 00 	mov    0x2013aa(%rip),%rax        # 201ff8 <__cxa_finalize@plt+0x201558>
c4e:	48 8b 38             	mov    (%rax),%rdi
c51:	48 8b 13             	mov    (%rbx),%rdx
c54:	48 8d 35 09 08 00 00 	lea    0x809(%rip),%rsi        # 1464 <__cxa_finalize@plt+0x9c4>
c5b:	31 c0                	xor    %eax,%eax
c5d:	e8 f6 fd ff ff       	callq  a58 <fprintf@plt>
c62:	eb d9                	jmp    c3d <__cxa_finalize@plt+0x19d>
```

如果edi==2的话，把rip的内容-23的地址给rsi，edi赋值为2，之前已经edi判断为2了，这里为什么还要赋值为2？看到后面的callq函数，我们知道，这是edi又作为一个参数调用signal这个函数，继续往下看，在rbx+8给rdi后，又call了一个函数，在对ce0处的这个函数分析，我们可以知道，这是一个将file open的功能，随后将1给r14所指的地方。nop没有查到，但是通过伪代码知道这应该是个死循环，再往后看，test eax自身，不相等的话跳c24.在c24处，比较了2和eax的值，不等于2的话，跳c35，调用_cxa_finalize函数。随后结束。如果eax等于2的话，在c29-c30处我们可以看到调用了一个puts的函数，用于输出。

ps：main()函数较长，所以明后继续进行分析。
